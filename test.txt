#include<iostream>
using namespace std;
template<class T>
class Node
{
    template<class U>  friend class LinkedList;
public:
    Node():prev(NULL),next(NULL) {}
    Node(T data):data(data),prev(NULL),next(NULL) {}
    Node(T data, Node<T> *prev, Node<T> *next):data(data),prev(prev),next(next) {}
    T getdata()const
    {
        return data;
    }
    Node<T>* getprev()const
    {
        return prev;
    }
    Node<T>* getnext()const
    {
        return next;
    }
private:
    Node<T> *prev;
    Node<T> *next;
    T data;
};
template<class T>
class LinkedList
{
    //template<class U>  friend class Queue;
public:
    LinkedList():head(NULL),tail(NULL) {}
    void addToTail(T data)
    {
        Node<T> *Newnode=new Node<T>(data);
        if (tail == NULL&&head==NULL)
        {
            tail=Newnode;
            head=Newnode;
        }
        else if(tail==head)
        {
            tail=Newnode;
            head->next=tail;
            tail->prev=head;
        }
        else
        {
            Node<T> *temp=tail;
            tail=Newnode;
            temp->next=tail;
            tail->prev=temp;
        }
    }
    void addToHead(T data)
    {
        Node<T> *Newnode=new Node<T>(data);
        if (tail == NULL&&head==NULL)
        {
            head=Newnode;
            tail=Newnode;
        }
        else if(tail==head)
        {
            head=Newnode;
            head->next=tail;
            tail->prev=head;
        }
        else
        {
            Node<T> *temp=head;
            head=Newnode;
            temp->prev=Newnode;
            head->next=temp;
        }
    }
    void deleteData(T data)
    {
        Node<T> *current = head;
        while(current!=NULL)
        {
            if(current->data==data)
            {
                if(current==head)
                {
                    if(head==tail)
                    {
                        head=NULL;
                        tail=NULL;
                    }
                    else
                    {
                        head=current->next;
                        head->prev=NULL;
                    }
                }
                else if(current==tail)
                {
                    if(head==tail)
                    {
                        head=NULL;
                        tail=NULL;
                    }
                    else
                    {
                        tail=current->prev;
                        tail->next=NULL;
                    }
                }
                else
                {
                    current->prev->next=current->next;
                    current->next->prev=current->prev;
                }
                delete current;
                break;
            }
            current=current->next;
        }
    }
    void deleteData(T data, int n)
    {
        int count=0;
        Node<T> *current = head;
        while(current!=NULL&&count<n)
        {
            if(current->data==data)
            {
                count++;
                if(current==head)
                {
                    if(head==tail)
                    {
                        head=NULL;
                        tail=NULL;
                        delete current;
                        return;
                    }
                    else
                    {
                        head=current->next;
                        head->prev=NULL;
                        Node<T> *temp = current;
                        current=head;
                        delete temp;
                    }
                }
                else if(current==tail)
                {

                    if(head==tail)
                    {
                        head=NULL;
                        tail=NULL;
                        delete current;
                        return;
                    }
                    else
                    {
                        tail=current->prev;
                        tail->next=NULL;
                        Node<T> *temp = current;
                        current=NULL;
                        delete temp;
                    }
                }
                else
                {
                    Node<T> *temp = current->next;
                    current->prev->next=current->next;
                    current->next->prev=current->prev;
                    Node<T> *tmp = current;
                    current=temp;
                    delete tmp;
                }
                continue;
            }
            current=current->next;
        }
    }
    friend std::ostream &operator<<(std::ostream &out, LinkedList * n)
    {
        if(n->head==NULL&&n->tail==NULL)
        {
            out<<endl;
        }
        else
        {
            Node<T> *current = n->head;
            if(n->head!=n->tail)
            {
                out<<"("<<current->getdata()<<",";
                current=current->getnext();
                while(true)
                {
                    if(current->getnext()!=NULL)
                        out<<" "<<current->getdata()<<",";
                    else
                    {
                        out<<" "<<current->getdata();
                        break;
                    }
                    current=current->getnext();
                }
                out<<")"<<endl;

            }else{
                out<<"("<<current->getdata()<<")"<<endl;
            }
        }
        return out;
    }
private:
    Node<T> *head;
    Node<T> *tail;
};

/**
 * A Queue class
 */
template<class T>
class Queue
{
  public:
  Queue():head(0),tail(0){}

  void enqueue(T data)
  {
    if(size == Max_size)
        return -1;
    tail++;
    size++;
    if(tail = Max_size)
        tail = 0;
    queue[tail] = data;
    return;

  }

  T dequeue(T Max_size)
  {
     int temp;
     if(size == 0)
        return -1;
     head++;
     size--;
     if(head == Max_size)
        head = 0;
     temp = queue[head];
     return temp;
  }

  /**
   * @return the first element in the queue
   */
  T front()
  {
     //return queue[];
  }

  /**
   * @return true if queue is empty, false otherwise
   */
  bool isEmpty()
  {
     if(head == tail)        //如何確定queue是空的--> head= tail
     {
         return true;
     }
     else
     {
         return false;
     }
  }

  private:
    LinkedList<T> *list;
};